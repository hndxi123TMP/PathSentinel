/*******************************************************************************
 * Some of the code in this class was borrowed from the FlowDroid project
 * (soot-infoflow and soot-infoflow-android).
 *
 * Copyright (c) 2012 Secure Software Engineering Group at EC SPRIDE.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser Public License v2.1
 * which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 ******************************************************************************/

package tiro.target.entrypoint;

import tiro.*;
import tiro.target.*;

import soot.*;
import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
import soot.jimple.infoflow.android.callbacks.AbstractCallbackAnalyzer;
import soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition;
import soot.jimple.infoflow.android.callbacks.DefaultCallbackAnalyzer;
import soot.jimple.infoflow.android.data.AndroidMethod;
import soot.jimple.infoflow.android.resources.ARSCFileParser;
import soot.jimple.infoflow.android.resources.ARSCFileParser.AbstractResource;
import soot.jimple.infoflow.android.resources.ARSCFileParser.StringResource;
import soot.jimple.infoflow.resources.controls.LayoutControl;
import soot.jimple.infoflow.android.resources.controls.AndroidLayoutControl;
import soot.jimple.infoflow.android.resources.LayoutFileParser;
import soot.jimple.infoflow.data.SootMethodAndClass;
import soot.jimple.infoflow.android.manifest.IManifestHandler;
import soot.util.MultiMap;
import soot.options.Options;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.*;
import java.util.Map.Entry;

// This classes uses the entrypoint extraction code from FlowDroid
// (i.e. the soot-infoflow and soot-infoflow-android projects)

// Note: The soot scene will be reset after the entry-point analysis has completed.
// Do not pass soot objects out of this class directly (use class/method names instead).

public class EntryPointAnalysis implements IEntryPointAnalysis {
    private final ManifestAnalysis _manifestAnalysis;
    private final ResourceAnalysis _resourceAnalysis;

    private CustomEntryPointCreator _entryPointCreator = null;
    private Set<String> _entryPointClasses = null;
    private Map<String, Set<SootMethodAndClass>> _callbackMethods =
            new HashMap<String, Set<SootMethodAndClass>>(10000);
    private Set<String> _additionalEntryPoints = new HashSet<String>(100);
    private Map<Integer, List<String>> _xmlCallbackMethods =
            new HashMap<Integer, List<String>>();

    public EntryPointAnalysis(ManifestAnalysis manifestAnalysis,
            ResourceAnalysis resourceAnalysis)
            throws Exception {
        try {
            java.io.PrintWriter debugFile = new java.io.PrintWriter("/tmp/tiro_debug_constructor.log");
            debugFile.println("EntryPointAnalysis constructor called");
            debugFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        _manifestAnalysis = manifestAnalysis;
        _resourceAnalysis = resourceAnalysis;
        _entryPointClasses = _manifestAnalysis.getEntryPointClasses();
        
        try {
            java.io.PrintWriter debugFile = new java.io.PrintWriter("/tmp/tiro_debug.log");
            debugFile.println("MANIFEST: Found " + _entryPointClasses.size() + " entry point classes from manifest:");
            for (String className : _entryPointClasses) {
                debugFile.println("  Manifest entry point: " + className);
            }
            debugFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        PrintStream originalOut = System.out;
        PrintStream originalErr = System.err;

        if (!TIROStaticAnalysis.Config.PrintSootOutput) {
            // Do not want excessive output from FlowDroid so temporariy disable stdout
            System.setOut(new PrintStream(new FileOutputStream("/dev/null")));
            System.setErr(new PrintStream(new FileOutputStream("/dev/null")));
        }

        try {
            calculateEntryPoints();
        } finally {
            System.setOut(originalOut);
            System.setErr(originalErr);
        }
    }

    public SootMethod getDummyMainMethod() {
        try {
            java.io.PrintWriter debugFile = new java.io.PrintWriter("/tmp/tiro_dummymain_debug.log");
            debugFile.println("getDummyMainMethod called");
            debugFile.println("_entryPointCreator is null: " + (_entryPointCreator == null));
            if (_entryPointCreator != null) {
                debugFile.println("About to call createDummyMain()");
            }
            debugFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        SootMethod entryPoint = _entryPointCreator.createDummyMain();

        // Always update the Scene to reflect the newest set of callback methods
        if (Scene.v().containsClass(entryPoint.getDeclaringClass().getName())) {
            Scene.v().removeClass(entryPoint.getDeclaringClass());
        }
        Scene.v().addClass(entryPoint.getDeclaringClass());

        // Need to set declaring class as an application (not library) class
        entryPoint.getDeclaringClass().setApplicationClass();

        //System.out.println(entryPoint.getActiveBody());
        return entryPoint;
    }

    public Set<MethodOrMethodContext> getEntryPoints() {
        //return _entryPointCreator.getEntryPoints();
        Set<MethodOrMethodContext> entrypoints = _entryPointCreator.getEntryPoints();
        System.err.println("ENTRYPOINT: FlowDroid found " + entrypoints.size() + " entry points");
        for (MethodOrMethodContext ep : entrypoints) {
            System.err.println("ENTRYPOINT:   " + ep.method().getSignature());
        }
        return entrypoints;
    }

    public Map<Integer, List<String>> getXmlCallbackMethods() {
        return _xmlCallbackMethods;
    }

    private void calculateEntryPoints() throws Exception {
        // Parse the resource and layout files
        LayoutFileParser lfp = new LayoutFileParser(_manifestAnalysis.getPackageName(),
                _resourceAnalysis.getResourceParser());

        // Find callback methods
        calculateCallbackMethods(_resourceAnalysis.getResourceParser(), lfp,
                _manifestAnalysis.getEntryPointClasses());

        // Clean up everything we no longer need
        //soot.G.reset();

        generateNewEntryPointCreator();
    }

    private void generateNewEntryPointCreator() {
        // Convert entry point class names to SootClass objects
        Set<SootClass> entryPointSootClasses = new HashSet<>();
        for (String className : _entryPointClasses) {
            if (Scene.v().containsClass(className)) {
                entryPointSootClasses.add(Scene.v().getSootClass(className));
                System.err.println("ENTRYPOINT CREATOR: Found SootClass for " + className);
            } else {
                System.err.println("ENTRYPOINT CREATOR: Missing SootClass for " + className);
            }
        }
        
        System.err.println("ENTRYPOINT CREATOR: Creating CustomEntryPointCreator with " + entryPointSootClasses.size() + " classes");
        
        // Create manifest handler from existing manifest analysis
        // TODO: Fix IManifestHandler compatibility - using null for now to get build working
        IManifestHandler manifestHandler = null;
        
        _entryPointCreator = new CustomEntryPointCreator(manifestHandler, entryPointSootClasses);

        soot.util.MultiMap<SootClass, SootMethod> callbackMethods = new soot.util.HashMultiMap<>();
        
        System.err.println("ENTRYPOINT CREATOR: Converting " + _callbackMethods.size() + " stored callback classes");
        for (String className : _callbackMethods.keySet()) {
            if (Scene.v().containsClass(className)) {
                SootClass sootClass = Scene.v().getSootClass(className);
                for (SootMethodAndClass methodAndClass : _callbackMethods.get(className)) {
                    try {
                        SootMethod method = Scene.v().getMethod(methodAndClass.getSignature());
                        callbackMethods.put(sootClass, method);
                        System.err.println("ENTRYPOINT CREATOR: Added callback: " + method.getSignature());
                    } catch (Exception e) {
                        // Method might not be resolvable, skip it
                        System.err.println("ENTRYPOINT CREATOR: Could not resolve callback: " + methodAndClass.getSignature());
                    }
                }
            }
        }

        // Manually add basic Android lifecycle methods for all component types
        for (String className : _entryPointClasses) {
            if (Scene.v().containsClass(className)) {
                SootClass componentClass = Scene.v().getSootClass(className);
                
                // Check component type and add appropriate lifecycle methods
                if (isActivityClass(componentClass)) {
                    addBasicActivityLifecycleMethods(componentClass, callbackMethods);
                } else if (isServiceClass(componentClass)) {
                    addBasicServiceLifecycleMethods(componentClass, callbackMethods);
                } else if (isContentProviderClass(componentClass)) {
                    addBasicContentProviderMethods(componentClass, callbackMethods);
                } else if (isBroadcastReceiverClass(componentClass)) {
                    addBasicBroadcastReceiverMethods(componentClass, callbackMethods);
                }
            }
        }
        
        // Force add MainActivity onCreate if no callbacks were found
        if (callbackMethods.isEmpty()) {
            System.err.println("ENTRYPOINT CREATOR: No callbacks found, manually adding MainActivity lifecycle methods");
            
            for (String className : _entryPointClasses) {
                if (className.contains("MainActivity") && Scene.v().containsClass(className)) {
                    SootClass mainActivity = Scene.v().getSootClass(className);
                    
                    // Add onCreate method
                    SootMethod onCreateMethod = mainActivity.getMethodUnsafe("void onCreate(android.os.Bundle)");
                    if (onCreateMethod != null) {
                        callbackMethods.put(mainActivity, onCreateMethod);
                        System.err.println("ENTRYPOINT CREATOR: Manually added onCreate: " + onCreateMethod.getSignature());
                    }
                    
                    // Add onResume method
                    SootMethod onResumeMethod = mainActivity.getMethodUnsafe("void onResume()");
                    if (onResumeMethod != null) {
                        callbackMethods.put(mainActivity, onResumeMethod);
                        System.err.println("ENTRYPOINT CREATOR: Manually added onResume: " + onResumeMethod.getSignature());
                    }
                }
            }
        }

        System.err.println("ENTRYPOINT CREATOR: Final callback count: " + callbackMethods.size());
        _entryPointCreator.setCallbackFunctions(callbackMethods);
    }

    private void calculateCallbackMethods(ARSCFileParser resParser,
                                          LayoutFileParser lfp,
                                          Set<String> entrypointClasses)
                                         throws IOException {
        try {
            java.io.PrintWriter debugFile = new java.io.PrintWriter("/tmp/tiro_callback_debug.log");
            debugFile.println("calculateCallbackMethods() called with " + entrypointClasses.size() + " classes");
            for (String className : entrypointClasses) {
                debugFile.println("  Class: " + className);
            }
            debugFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.err.println("CALLBACK ANALYSIS: Starting callback analysis for " + entrypointClasses.size() + " entry point classes");
        for (String className : entrypointClasses) {
            System.err.println("  Entry point class: " + className);
        }

        AbstractCallbackAnalyzer jimpleClass = null;
        Set<String> callbackClasses = null;
        InfoflowAndroidConfiguration config = new InfoflowAndroidConfiguration();

        boolean hasChanged = true;
        int iteration = 0;
        while (hasChanged) {
            iteration++;
            Output.debug("CALLBACK ANALYSIS: Iteration " + iteration);
            hasChanged = false;

            // Create a new entrypoint creator with updated callback methods
            generateNewEntryPointCreator();

            // Create the new iteration of the main method
            TIROStaticAnalysis.initializeSoot();
            Scene.v().setEntryPoints(Collections.singletonList(getDummyMainMethod()));

            if (jimpleClass == null) {
                // Convert entry point class names to SootClass objects
                Set<SootClass> entryPointSootClasses = new HashSet<>();
                for (String className : _entryPointClasses) {
                    if (Scene.v().containsClass(className)) {
                        entryPointSootClasses.add(Scene.v().getSootClass(className));
                    }
                }
                
                // Collect the callback interfaces implemented in the app's source code
                MultiMap<SootClass, AndroidCallbackDefinition> emptyViewCallbacks = new soot.util.HashMultiMap<>();
                Output.debug("CALLBACK ANALYSIS: Creating DefaultCallbackAnalyzer with " + entryPointSootClasses.size() + " classes");
                for (SootClass sc : entryPointSootClasses) {
                    System.err.println("CALLBACK ANALYSIS:   Class: " + sc.getName());
                }
                jimpleClass = new DefaultCallbackAnalyzer(config, entryPointSootClasses, emptyViewCallbacks, new HashSet<String>());
                
                Output.debug("CALLBACK ANALYSIS: Calling collectCallbackMethods() for first time");
                jimpleClass.collectCallbackMethods();
                System.err.println("CALLBACK ANALYSIS: After collectCallbackMethods(), found " + jimpleClass.getCallbackMethods().size() + " callbacks");
                for (SootClass classKey : jimpleClass.getCallbackMethods().keySet()) {
                    System.err.println("CALLBACK ANALYSIS:   Callbacks for " + classKey.getName() + ": " + jimpleClass.getCallbackMethods().get(classKey).size());
                }

                // Find the user-defined sources in the layout XML files. This
                // only needs to be done once, but is a Soot phase.
                lfp.parseLayoutFile(new File(TIROStaticAnalysis.Config.ApkFile));
            } else {
                System.err.println("CALLBACK ANALYSIS: Calling collectCallbackMethods() for second+ time");
                jimpleClass.collectCallbackMethods();
                System.err.println("CALLBACK ANALYSIS: After second collectCallbackMethods(), found " + jimpleClass.getCallbackMethods().size() + " callbacks");
            }

            // Run the soot-based operations
            PackManager.v().getPack("wjpp").apply();
            
            // Ensure hierarchy is built before call graph analysis
            Scene.v().getOrMakeFastHierarchy();
            
            PackManager.v().getPack("cg").apply();
            PackManager.v().getPack("wjtp").apply();

            // Collect the results of the soot-based phases
            Output.debug("CALLBACK ANALYSIS: Collecting results from jimpleClass.getCallbackMethods()");
            soot.util.MultiMap<SootClass, soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition> callbackMap = jimpleClass.getCallbackMethods();
            Output.debug("CALLBACK ANALYSIS: CallbackMethods map has " + callbackMap.size() + " entries");
            
            for (SootClass classKey : callbackMap.keySet()) {
                Set<soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition> callbacks = callbackMap.get(classKey);
                String className = classKey.getName();
                
                Output.debug("Found " + callbacks.size() + " callbacks for class: " + className);
                
                Set<SootMethodAndClass> curCallbacks = _callbackMethods.get(className);
                if (curCallbacks == null) {
                    curCallbacks = new HashSet<>();
                    _callbackMethods.put(className, curCallbacks);
                    hasChanged = true;
                }
                
                for (soot.jimple.infoflow.android.callbacks.AndroidCallbackDefinition callback : callbacks) {
                    // Convert AndroidCallbackDefinition to SootMethodAndClass
                    SootMethodAndClass smaCallback = new SootMethodAndClass(callback.getTargetMethod());
                    Output.debug("  Callback: " + smaCallback.getSignature());
                    if (curCallbacks.add(smaCallback)) {
                        hasChanged = true;
                    }
                }
            }

            for (SootClass dynamicComponent : jimpleClass.getDynamicManifestComponents()) {
                if (_entryPointClasses.add(dynamicComponent.getName())) {
                    hasChanged = true;
                }
            }

            // Specifically handle unresolvable broadcast receiver registrations by
            // heuristically adding all receivers that are inner classes of a registration.
            // Note: getUnresolvableDynamicRegistrations() not available in FlowDroid 2.14.1
            Set<SootClass> unresolvedRegistrations = new HashSet<>();
            SootClass receiverClass =
                    Scene.v().getSootClass("android.content.BroadcastReceiver");
            
            // Ensure hierarchy is available
            if (!Scene.v().hasActiveHierarchy()) {
                Scene.v().getOrMakeFastHierarchy();
            }
            
            for (SootClass receiverSubclass
                    : Scene.v().getActiveHierarchy().getSubclassesOf(receiverClass)) {
                if (!receiverSubclass.isApplicationClass()
                        || !receiverSubclass.hasOuterClass()) {
                    continue;
                }
                if (unresolvedRegistrations.contains(receiverSubclass.getOuterClass())) {
                    if (_entryPointClasses.add(receiverSubclass.getName())) {
                        Output.debug("Heuristically adding receiver: " + receiverSubclass);
                        hasChanged = true;
                    }
                }
            }

            // Handle view-based callback methods for custom views.
            hasChanged |= calculateViewBasedCallbackMethods();
        }

        // Collect the XML-based callback methods
        collectXmlBasedCallbackMethods(resParser, lfp, jimpleClass);
    }

    /**
     * Collects the XML-based callback methods, e.g., Button.onClick() declared
     * in layout XML files
     * @param resParser The ARSC resource parser
     * @param lfp The layout file parser
     * @param jimpleClass The analysis class that gives us a mapping between
     * layout IDs and components
     */
    private void collectXmlBasedCallbackMethods(ARSCFileParser resParser,
            LayoutFileParser lfp, AbstractCallbackAnalyzer jimpleClass) {
        // Collect the XML-based callback methods
        for (SootClass callbackClass : jimpleClass.getLayoutClasses().keySet()) {
            Set<Integer> classIds = jimpleClass.getLayoutClasses().get(callbackClass);

            for (Integer classId : classIds) {
                AbstractResource resource = resParser.findResource(classId);
                if (resource instanceof StringResource) {
                    final String layoutFileName = ((StringResource) resource).getValue();

                    // Add the callback methods for the given class
                    Set<String> callbackMethods = lfp.getCallbackMethods().get(layoutFileName);
                    if (callbackMethods != null) {
                        for (String methodName : callbackMethods) {
                            final String subSig = "void " + methodName + "(android.view.View)";

                            // The callback may be declared directly in the
                            // class
                            // or in one of the superclasses
                            SootClass currentClass = callbackClass;
                            while (true) {
                                SootMethod callbackMethod =
                                        currentClass.getMethodUnsafe(subSig);
                                if (callbackMethod != null) {
                                    addCallbackMethod(callbackClass.getName(),
                                            new AndroidMethod(callbackMethod));
                                    _xmlCallbackMethods.computeIfAbsent(classId,
                                            k -> new ArrayList<String>()).add(
                                                callbackMethod.getSignature());
                                    break;
                                }
                                if (!currentClass.hasSuperclass()) {
                                    System.err.println("Callback method " + methodName
                                            + " not found in class "
                                            + callbackClass);
                                    break;
                                }
                                currentClass = currentClass.getSuperclass();
                            }
                        }
                    }

                    // For user-defined views, we need to emulate their
                    // callbacks
                    Set<AndroidLayoutControl> controls = lfp.getUserControls().get(layoutFileName);
                    if (controls != null) {
                        for (AndroidLayoutControl lc : controls) {
                            registerCallbackMethodsForView(classId, callbackClass, lc);
                        }
                    }
                } else {
                    System.err.println("Unexpected resource type for layout class");
                }
            }
        }

        // Add the callback methods as sources and sinks
        //{
        //  Set<SootMethodAndClass> callbacksPlain = new HashSet<SootMethodAndClass>();
        //  for (Set<SootMethodAndClass> set : _callbackMethods.values()) {
        //      callbacksPlain.addAll(set);
        //    }

        //  System.out.println("Found " + callbacksPlain.size() + " callback methods for "
        //          + this.callbackMethods.size() + " components");
        //}
    }

    /**
     * Registers the callback methods in the given layout control so that they
     * are included in the dummy main method
     * @param classId The class ID with which to associate the layout
     * callbacks
     * @param callbackClass The class with which to associate the layout
     * callbacks
     * @param lc The layout control whose callbacks are to be associated with
     * the given class
     */
    private void registerCallbackMethodsForView(int classId, SootClass callbackClass,
            AndroidLayoutControl lc) {
        // Ignore system classes
        if (callbackClass.getName().startsWith("android.")) {
            return;
        }
        if (lc.getViewClass().getName().startsWith("android.")) {
            return;
        }

        // Check whether the current class is actually a view
        {
            SootClass sc = lc.getViewClass();
            boolean isView = false;
            while (sc.hasSuperclass()) {
                if (sc.getName().equals("android.view.View")) {
                    isView = true;
                    break;
                }
                sc = sc.getSuperclass();
            }
            if (!isView) {
                return;
            }
        }

        // There are also some classes that implement interesting callback
        // methods.
        // We model this as follows: Whenever the user overwrites a method in an
        // Android OS class, we treat it as a potential callback.
        SootClass sc = lc.getViewClass();
        Set<String> systemMethods = new HashSet<String>(10000);
        
        // Ensure hierarchy is available
        if (!Scene.v().hasActiveHierarchy()) {
            Scene.v().getOrMakeFastHierarchy();
        }
        
        for (SootClass parentClass : Scene.v().getActiveHierarchy().getSuperclassesOf(sc)) {
            if (parentClass.getName().startsWith("android.")) {
                for (SootMethod sm : parentClass.getMethods()) {
                    if (!sm.isConstructor()) {
                        systemMethods.add(sm.getSubSignature());
                    }
                }
            }
        }

        // Scan for methods that overwrite parent class methods
        for (SootMethod sm : sc.getMethods()) {
            if (!sm.isConstructor()) {
                if (systemMethods.contains(sm.getSubSignature())) {
                    // This is a real callback method
                    addCallbackMethod(callbackClass.getName(), new AndroidMethod(sm));
                    _xmlCallbackMethods.computeIfAbsent(classId, k -> new ArrayList<String>())
                            .add(sm.getSignature());
                }
            }
        }
    }

    private void addCallbackMethod(String layoutClass, AndroidMethod callbackMethod) {
        if (!_callbackMethods.containsKey(layoutClass)) {
            _callbackMethods.put(layoutClass, new HashSet<SootMethodAndClass>());
        }

        _callbackMethods.get(layoutClass).add(new AndroidMethod(callbackMethod));
    }

    private boolean calculateViewBasedCallbackMethods() {
        boolean hasChanged = false;

        SootClass viewClass = Scene.v().getSootClass("android.view.View");
        Set<String> viewMethods = new HashSet<String>(50);
        for (SootMethod viewMethod : viewClass.getMethods()) {
            if (!viewMethod.isConstructor() && !viewMethod.getName().equals("<clinit>")) {
                viewMethods.add(viewMethod.getSubSignature());
            }
        }

        // Scan for methods that overwrite parent view class methods
        for (MethodOrMethodContext entryPoint : getEntryPoints()) {
            SootClass entryPointClass = entryPoint.method().getDeclaringClass();
            
            // Ensure hierarchy is available
            if (!Scene.v().hasActiveHierarchy()) {
                Scene.v().getOrMakeFastHierarchy();
            }
            
            if (!Scene.v().getActiveHierarchy().isClassSubclassOf(entryPointClass,
                    viewClass)) {
                continue;
            }

            for (SootMethod viewSubclassMethod : entryPointClass.getMethods()) {
                if (viewMethods.contains(viewSubclassMethod.getSubSignature())) {
                    if (!_additionalEntryPoints.contains(viewSubclassMethod.getSignature())) {
                        Output.debug("Adding view callback: " + viewSubclassMethod);
                        _additionalEntryPoints.add(viewSubclassMethod.getSignature());
                        hasChanged = true;
                    }
                }
            }
        }

        return hasChanged;
    }
    
    private boolean isActivityClass(SootClass componentClass) {
        // Ensure hierarchy is available
        if (!Scene.v().hasActiveHierarchy()) {
            Scene.v().getOrMakeFastHierarchy();
        }
        
        try {
            SootClass activityClass = Scene.v().getSootClass("android.app.Activity");
            return Scene.v().getActiveHierarchy().isClassSubclassOf(componentClass, activityClass) 
                   || componentClass.getName().equals("android.app.Activity");
        } catch (Exception e) {
            // If we can't find android.app.Activity, fall back to name-based check
            return componentClass.getName().contains("Activity");
        }
    }
    
    private void addBasicActivityLifecycleMethods(SootClass activityClass, 
                                                soot.util.MultiMap<SootClass, SootMethod> callbackMethods) {
        // List of basic Android Activity lifecycle methods
        String[] lifecycleMethods = {
            "void onCreate(android.os.Bundle)",
            "void onStart()",
            "void onResume()",
            "void onPause()",
            "void onStop()",
            "void onDestroy()",
            "void onRestart()"
        };
        
        for (String methodSig : lifecycleMethods) {
            try {
                SootMethod lifecycleMethod = activityClass.getMethodUnsafe(methodSig);
                if (lifecycleMethod != null && lifecycleMethod.hasActiveBody()) {
                    callbackMethods.put(activityClass, lifecycleMethod);
                    System.err.println("MANUAL LIFECYCLE: Added " + lifecycleMethod.getSignature());
                }
            } catch (Exception e) {
                // Method not found or not implemented, skip it
            }
        }
    }
    
    private boolean isServiceClass(SootClass componentClass) {
        if (!Scene.v().hasActiveHierarchy()) {
            Scene.v().getOrMakeFastHierarchy();
        }
        
        try {
            SootClass serviceClass = Scene.v().getSootClass("android.app.Service");
            return Scene.v().getActiveHierarchy().isClassSubclassOf(componentClass, serviceClass) 
                   || componentClass.getName().equals("android.app.Service");
        } catch (Exception e) {
            return componentClass.getName().contains("Service");
        }
    }
    
    private boolean isContentProviderClass(SootClass componentClass) {
        if (!Scene.v().hasActiveHierarchy()) {
            Scene.v().getOrMakeFastHierarchy();
        }
        
        try {
            SootClass providerClass = Scene.v().getSootClass("android.content.ContentProvider");
            return Scene.v().getActiveHierarchy().isClassSubclassOf(componentClass, providerClass) 
                   || componentClass.getName().equals("android.content.ContentProvider");
        } catch (Exception e) {
            return componentClass.getName().contains("Provider");
        }
    }
    
    private boolean isBroadcastReceiverClass(SootClass componentClass) {
        if (!Scene.v().hasActiveHierarchy()) {
            Scene.v().getOrMakeFastHierarchy();
        }
        
        try {
            SootClass receiverClass = Scene.v().getSootClass("android.content.BroadcastReceiver");
            return Scene.v().getActiveHierarchy().isClassSubclassOf(componentClass, receiverClass) 
                   || componentClass.getName().equals("android.content.BroadcastReceiver");
        } catch (Exception e) {
            return componentClass.getName().contains("Receiver");
        }
    }
    
    private void addBasicServiceLifecycleMethods(SootClass serviceClass, 
                                               soot.util.MultiMap<SootClass, SootMethod> callbackMethods) {
        String[] lifecycleMethods = {
            "void onCreate()",
            "int onStartCommand(android.content.Intent,int,int)",
            "android.os.IBinder onBind(android.content.Intent)",
            "void onDestroy()"
        };
        
        for (String methodSig : lifecycleMethods) {
            try {
                SootMethod lifecycleMethod = serviceClass.getMethodUnsafe(methodSig);
                if (lifecycleMethod != null && lifecycleMethod.hasActiveBody()) {
                    callbackMethods.put(serviceClass, lifecycleMethod);
                    System.err.println("MANUAL LIFECYCLE: Added Service method " + lifecycleMethod.getSignature());
                }
            } catch (Exception e) {
                // Method not found or not implemented, skip it
            }
        }
    }
    
    private void addBasicContentProviderMethods(SootClass providerClass, 
                                              soot.util.MultiMap<SootClass, SootMethod> callbackMethods) {
        String[] lifecycleMethods = {
            "boolean onCreate()",
            "android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)",
            "android.net.Uri insert(android.net.Uri,android.content.ContentValues)",
            "int update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])",
            "int delete(android.net.Uri,java.lang.String,java.lang.String[])",
            "java.lang.String getType(android.net.Uri)"
        };
        
        for (String methodSig : lifecycleMethods) {
            try {
                SootMethod lifecycleMethod = providerClass.getMethodUnsafe(methodSig);
                if (lifecycleMethod != null && lifecycleMethod.hasActiveBody()) {
                    callbackMethods.put(providerClass, lifecycleMethod);
                    System.err.println("MANUAL LIFECYCLE: Added ContentProvider method " + lifecycleMethod.getSignature());
                }
            } catch (Exception e) {
                // Method not found or not implemented, skip it
            }
        }
    }
    
    private void addBasicBroadcastReceiverMethods(SootClass receiverClass, 
                                                soot.util.MultiMap<SootClass, SootMethod> callbackMethods) {
        String[] lifecycleMethods = {
            "void onReceive(android.content.Context,android.content.Intent)"
        };
        
        for (String methodSig : lifecycleMethods) {
            try {
                SootMethod lifecycleMethod = receiverClass.getMethodUnsafe(methodSig);
                if (lifecycleMethod != null && lifecycleMethod.hasActiveBody()) {
                    callbackMethods.put(receiverClass, lifecycleMethod);
                    System.err.println("MANUAL LIFECYCLE: Added BroadcastReceiver method " + lifecycleMethod.getSignature());
                }
            } catch (Exception e) {
                // Method not found or not implemented, skip it
            }
        }
    }
}
